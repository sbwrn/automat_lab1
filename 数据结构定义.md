# 自动机数据结构

## 面向对象方面

通过导入abc模块，定义创建抽象基类

像c++虚函数继承一样，通过@abc.abstractmethod标记的方法规定要求在其子类中提供自己的实现

## 抽象对象

### Automaton 自动机顶层抽象基类

继承自abc.ABC，其中定义了自动机共有的属性和方法

由于python不需要像c++一样在private中强制访问控制，自动机中的元素对象声明被放到了__init__中

python中的在 [**init**](vscode-file://vscode-app/d:/Microsoft%20VS%20Code/resources/app/out/vs/code/electron-sandbox/workbench/workbench.html) 方法内部执行 [self.Q = Q](vscode-file://vscode-app/d:/Microsoft%20VS%20Code/resources/app/out/vs/code/electron-sandbox/workbench/workbench.html) 这样的赋值语句时，实际上是在 **创建** （如果尚不存在）并**初始化**这个实例的成员变量 [self.Q](vscode-file://vscode-app/d:/Microsoft%20VS%20Code/resources/app/out/vs/code/electron-sandbox/workbench/workbench.html)，并将传入的参数 [Q](vscode-file://vscode-app/d:/Microsoft%20VS%20Code/resources/app/out/vs/code/electron-sandbox/workbench/workbench.html) 的值赋给它

### 变量

在自动机的抽象基类中，我们定义了以下变量，都是python中的集合（set）

|      Q (set): 状态集合      |
| :-------------------------: |
|     T (set): 输入字母表     |
| transitions (set): 转移函数 |
|        q0: 起始状态        |
|    F (set): 接受状态集合    |

### 函数

自动机有如下通过@abc.abstractmethod标记的方法

#### def _initialize_transitions(self):

初始化转移函数（集合），返回一个空集

#### def add_transition(self, *args):

添加初态、输出、终态，生成一个字典并存储在转移函数中

#### def get_next_Q(self, current_state, symbol):

根据当前状态和输入符号获取下一个状态

#### def__repr__(self):

一个统一输出函数，可被print直接调用（即print(name_of_automaton))


### EpsilonNFA 

继承自自动机automaton

其中多了一个获取Epsilon闭包的函数

#### get _epsilon_closure(self, state_or_Q):

通过队列遍历当前状态/集合中所有的状态，对每一个状态进行处理得到闭包集合


### NFA

直接继承EpsilonNFA，但是其中的defget_epsilon_closure(self, state_or_Q):并不需要


### DFA

增加一些差错检测，比如说：确定性：同一个输入不应有多个不同的下一状态

检查 DFA 是否完整 def is_complete(self):
